<%
  require 'json'
  require 'securerandom'

  broker = p('seaweedfs.broker')

  # Handle shared cluster endpoint from link or property
  shared_s3_endpoint = p('seaweedfs.broker.shared_cluster.s3_endpoint')
  shared_cluster_enabled = p('seaweedfs.broker.shared_cluster.enabled')
  use_dns = p('seaweedfs.broker.shared_cluster.use_dns', true)

  # Internal endpoint for IAM operations (bypasses gorouter)
  internal_s3_endpoint = ""

  if_link('seaweedfs-s3') do |s3_link|
    s3_instance = s3_link.instances.first
    s3_port = s3_link.p('seaweedfs.s3.port')

    # Always capture internal endpoint for IAM operations
    internal_s3_endpoint = "#{s3_instance.address}:#{s3_port}"

    if shared_s3_endpoint.empty? && shared_cluster_enabled
      # Use BOSH DNS name if available and use_dns is enabled, otherwise fall back to IP
      if use_dns && s3_instance.respond_to?(:dns) && !s3_instance.dns.nil?
        shared_s3_endpoint = "#{s3_instance.dns}:#{s3_port}"
      else
        shared_s3_endpoint = "#{s3_instance.address}:#{s3_port}"
      end
    end
  end

  # Parse on-demand plans from tile service_plan_forms
  on_demand_plans_raw = p('seaweedfs.broker.on_demand.plans')
  on_demand_network = p('seaweedfs.broker.on_demand.network')
  on_demand_azs = p('seaweedfs.broker.on_demand.azs')

  # Handle azs - could be array or comma-separated string
  if on_demand_azs.is_a?(String)
    on_demand_azs = on_demand_azs.split(',').map(&:strip)
  end

  on_demand_plans = []
  if on_demand_plans_raw.is_a?(Array) && !on_demand_plans_raw.empty?
    on_demand_plans = on_demand_plans_raw.map do |plan|
      # Generate a stable plan ID from the plan GUID if provided
      plan_id = plan['guid'] || "ondemand-#{SecureRandom.uuid}"
      plan_name = plan['name'] || "ondemand-#{plan_id[0..7]}"

      # Map deployment_type to node counts
      deployment_type = plan['deployment_type'] || 'single_node'
      if deployment_type == 'ha'
        master_nodes = 3
        volume_nodes = 6
        filer_nodes = 3
        replication = '010'  # Different rack for HA
      else
        # single_node deployment
        master_nodes = 1
        volume_nodes = 1
        filer_nodes = 1
        replication = '000'  # No replication for single node
      end

      {
        'id' => plan_id,
        'name' => plan_name,
        'description' => plan['plan_description'] || "On-demand SeaweedFS cluster (#{deployment_type == 'ha' ? 'HA' : 'Single Node'})",
        'free' => false,
        'plan_type' => 'dedicated',
        'deployment_type' => deployment_type,
        'storage_quota_gb' => plan['storage_quota_gb'] || 100,
        'dedicated_config' => {
          'vm_type' => plan['vm_type'] || 'medium',
          'disk_type' => plan['disk_type'] || '50GB',
          'master_nodes' => master_nodes,
          'volume_nodes' => volume_nodes,
          'filer_nodes' => filer_nodes,
          'replication' => replication,
          'network' => on_demand_network,
          'azs' => on_demand_azs,
          'enable_master_route' => plan['enable_master_console_route'] || false,
          'enable_filer_route' => plan['enable_filer_console_route'] || false,
          'enable_volume_route' => plan['enable_volume_console_route'] || false,
          'enable_admin_route' => plan['enable_admin_console_route'] || false
        }
      }
    end
  end

  # Build static plans list - only include shared if enabled
  shared_plan_name = p('seaweedfs.broker.shared_cluster.plan_name', 'shared')
  shared_plan_description = p('seaweedfs.broker.shared_cluster.plan_description', 'Shared SeaweedFS cluster with dedicated bucket')
  static_plans = []
  if shared_cluster_enabled
    static_plans << {
      'id' => 'shared-bucket',
      'name' => shared_plan_name,
      'description' => shared_plan_description,
      'free' => true,
      'plan_type' => 'shared'
    }
  end

  # Merge static plans with on-demand plans
  all_plans = static_plans + on_demand_plans
%>
---
listen_addr: ":<%= p('seaweedfs.broker.port') %>"
log_level: "<%= p('seaweedfs.broker.log_level') %>"

auth:
  username: "<%= p('seaweedfs.broker.auth.username') %>"
  password: "<%= p('seaweedfs.broker.auth.password') %>"

tls:
  enabled: <%= p('seaweedfs.broker.tls.enabled') %>
<% if p('seaweedfs.broker.tls.enabled') %>
  cert_file: "/var/vcap/jobs/seaweedfs-broker/config/certs/server.crt"
  key_file: "/var/vcap/jobs/seaweedfs-broker/config/certs/server.key"
<% end %>

catalog:
  services:
    - id: "<%= p('seaweedfs.broker.catalog.service_id') %>"
      name: "<%= p('seaweedfs.broker.catalog.service_name') %>"
      description: "<%= p('seaweedfs.broker.catalog.service_description') %>"
      bindable: true
      tags:
        - seaweedfs
        - s3
        - object-storage
        - blob-storage
      metadata:
        displayName: "SeaweedFS"
<% icon_url = p('seaweedfs.broker.catalog.icon_url', '') %>
        imageUrl: "<%= icon_url %>"
        longDescription: "SeaweedFS is a distributed storage system for blobs, objects, files, and data lake storage, with O(1) disk seek and cloud tiering. This service allows developers to easily create and bind to on-demand S3 buckets from a shared cluster across the foundation. Additionally, for large scale projects, developers can provision dedicated SeaweedFS clusters on demand.\nThis service is experimental and a community driven project created by Kuhn Labs. Use at your own risk.\nSee the upstream OSS project: https://github.com/seaweedfs/seaweedfs"
        providerDisplayName: "Kuhn Labs"
        documentationUrl: "https://github.com/seaweedfs/seaweedfs/wiki"
        supportUrl: "https://github.com/seaweedfs/seaweedfs/issues"
      plans:
<% all_plans.each do |plan| %>
        - id: "<%= plan['id'] %>"
          name: "<%= plan['name'] %>"
          description: "<%= plan['description'] %>"
          free: <%= plan['free'] %>
          plan_type: "<%= plan['plan_type'] %>"
          metadata:
            displayName: "<%= plan['name'].capitalize %>"
            bullets:
<% if plan['plan_type'] == 'shared' %>
              - "Shared SeaweedFS cluster"
              - "Dedicated S3 bucket"
              - "S3-compatible API"
<% else %>
              - "Dedicated SeaweedFS cluster"
              - "Isolated compute and storage"
              - "Configurable cluster size"
<% end %>
<% if plan['dedicated_config'] %>
          dedicated_config:
            vm_type: "<%= plan['dedicated_config']['vm_type'] %>"
            disk_type: "<%= plan['dedicated_config']['disk_type'] %>"
            master_nodes: <%= plan['dedicated_config']['master_nodes'] %>
            volume_nodes: <%= plan['dedicated_config']['volume_nodes'] %>
            filer_nodes: <%= plan['dedicated_config']['filer_nodes'] %>
            replication: "<%= plan['dedicated_config']['replication'] || '001' %>"
            network: "<%= plan['dedicated_config']['network'] %>"
            azs:
<% plan['dedicated_config']['azs'].each do |az| %>
              - "<%= az %>"
<% end %>
            enable_master_route: <%= plan['dedicated_config']['enable_master_route'] || false %>
            enable_filer_route: <%= plan['dedicated_config']['enable_filer_route'] || false %>
            enable_volume_route: <%= plan['dedicated_config']['enable_volume_route'] || false %>
            enable_admin_route: <%= plan['dedicated_config']['enable_admin_route'] || false %>
<% end %>
<% end %>

shared_cluster:
  enabled: <%= shared_cluster_enabled %>
  s3_endpoint: "<%= shared_s3_endpoint %>"
  # Internal endpoint for IAM operations (direct connection, no gorouter)
  iam_endpoint: "<%= internal_s3_endpoint %>"
  filer_endpoint: "<%= p('seaweedfs.broker.shared_cluster.filer_endpoint') %>"
  access_key: "<%= p('seaweedfs.broker.shared_cluster.access_key') %>"
  secret_key: "<%= p('seaweedfs.broker.shared_cluster.secret_key') %>"
  use_ssl: <%= p('seaweedfs.broker.shared_cluster.use_ssl') %>
  region: "<%= p('seaweedfs.broker.shared_cluster.region') %>"

cf:
  system_domain: "<%= p('seaweedfs.broker.cf.system_domain', '') %>"
  apps_domain: "<%= p('seaweedfs.broker.cf.apps_domain', '') %>"
  deployment_name: "<%= p('seaweedfs.broker.cf.deployment_name', '') %>"

bosh:
  url: "<%= p('seaweedfs.broker.bosh.url') %>"
<% bosh_ca_cert = p('seaweedfs.broker.bosh.root_ca_cert') %>
<% if !bosh_ca_cert.to_s.empty? %>
  root_ca_cert: |
<%= bosh_ca_cert.gsub(/^/, '    ') %>
<% end %>
  authentication:
    uaa:
      url: "<%= p('seaweedfs.broker.bosh.authentication.uaa.url') %>"
      client_id: "<%= p('seaweedfs.broker.bosh.authentication.uaa.client_id') %>"
      client_secret: "<%= p('seaweedfs.broker.bosh.authentication.uaa.client_secret') %>"
  deployment_prefix: "<%= p('seaweedfs.broker.bosh.deployment_prefix') %>"
  release_name: "<%= p('seaweedfs.broker.bosh.release_name') %>"
  release_version: "<%= p('seaweedfs.broker.bosh.release_version') %>"
  stemcell_os: "<%= p('seaweedfs.broker.on_demand.stemcell_os') %>"
  stemcell_version: "<%= p('seaweedfs.broker.on_demand.stemcell_version') %>"
  routing_release_version: "<%= p('seaweedfs.broker.on_demand.routing_release_version', 'latest') %>"

# NATS configuration for on-demand route registration
<%
  # Discover NATS config from the nats-tls link (cross-deployment)
  nats_machines = []
  nats_port = 4224
  nats_user = ""
  nats_password = ""
  if_link('nats-tls') do |nats_link|
    nats_link.instances.each do |instance|
      nats_machines << instance.address
    end
    nats_port = nats_link.p('nats.port', 4224) rescue 4224
    nats_user = nats_link.p('nats.user', '') rescue ''
    nats_password = nats_link.p('nats.password', '') rescue ''
  end
%>
nats:
<% if !nats_machines.empty? %>
  machines:
<% nats_machines.each do |machine| %>
    - "<%= machine %>"
<% end %>
  port: <%= nats_port %>
<% end %>
<% if !nats_user.to_s.empty? %>
  user: "<%= nats_user %>"
  password: "<%= nats_password %>"
<% end %>
  tls:
    enabled: <%= p('seaweedfs.broker.nats.tls.enabled', true) %>
<% nats_client_cert = p('seaweedfs.broker.nats.tls.client_cert', '') %>
<% nats_client_key = p('seaweedfs.broker.nats.tls.client_key', '') %>
<% nats_ca_cert = p('seaweedfs.broker.nats.tls.ca_cert', '') %>
<% if !nats_client_cert.to_s.empty? %>
    client_cert: |
<%= nats_client_cert.gsub(/^/, '      ') %>
    client_key: |
<%= nats_client_key.gsub(/^/, '      ') %>
    ca_cert: |
<%= nats_ca_cert.gsub(/^/, '      ') %>
<% end %>

state_store:
  type: "file"
  path: "/var/vcap/store/seaweedfs-broker/state.json"

# Syslog forwarding configuration for on-demand deployments
syslog:
  address: "<%= p('seaweedfs.broker.on_demand.syslog.address', '') %>"
  transport: "<%= p('seaweedfs.broker.on_demand.syslog.transport', 'tcp') %>"
  tls_enabled: <%= p('seaweedfs.broker.on_demand.syslog.tls_enabled', false) %>
<% syslog_ca = p('seaweedfs.broker.on_demand.syslog.ca_cert', '') %>
<% if !syslog_ca.to_s.empty? %>
  ca_cert: |
<%= syslog_ca.gsub(/^/, '    ') %>
<% end %>
  permitted_peer: "<%= p('seaweedfs.broker.on_demand.syslog.permitted_peer', '') %>"

# OpenTelemetry configuration for on-demand deployments
otel:
  otlp_endpoint: "<%= p('seaweedfs.broker.on_demand.otel.otlp_endpoint', '') %>"
  otlp_protocol: "<%= p('seaweedfs.broker.on_demand.otel.otlp_protocol', 'grpc') %>"
<% otlp_ca = p('seaweedfs.broker.on_demand.otel.otlp_ca_cert', '') %>
<% if !otlp_ca.to_s.empty? %>
  otlp_ca_cert: |
<%= otlp_ca.gsub(/^/, '    ') %>
<% end %>
  otlp_auth_header: "<%= p('seaweedfs.broker.on_demand.otel.otlp_auth_header', '') %>"
  scrape_interval: "<%= p('seaweedfs.broker.on_demand.otel.scrape_interval', '30s') %>"
  enable_host_metrics: <%= p('seaweedfs.broker.on_demand.otel.enable_host_metrics', true) %>

# Backup configuration for on-demand deployments
backup:
  enabled: <%= p('seaweedfs.broker.on_demand.backup.enabled', false) %>
  schedule: "<%= p('seaweedfs.broker.on_demand.backup.schedule', '0 2 * * *') %>"
  destination_type: "<%= p('seaweedfs.broker.on_demand.backup.destination_type', 'local') %>"
  s3_endpoint: "<%= p('seaweedfs.broker.on_demand.backup.s3_endpoint', '') %>"
  s3_bucket: "<%= p('seaweedfs.broker.on_demand.backup.s3_bucket', '') %>"
  s3_access_key: "<%= p('seaweedfs.broker.on_demand.backup.s3_access_key', '') %>"
  s3_secret_key: "<%= p('seaweedfs.broker.on_demand.backup.s3_secret_key', '') %>"
  retention_count: <%= p('seaweedfs.broker.on_demand.backup.retention_count', 7) %>

<% credhub_url = p('seaweedfs.broker.credhub.url', '') %>
<% if !credhub_url.to_s.empty? %>
credhub:
  url: "<%= credhub_url %>"
  client_id: "<%= p('seaweedfs.broker.credhub.client_id', '') %>"
  client_secret: "<%= p('seaweedfs.broker.credhub.client_secret', '') %>"
<% credhub_ca = p('seaweedfs.broker.credhub.ca_cert', '') %>
<% if !credhub_ca.to_s.empty? %>
  ca_cert: |
<%= credhub_ca.gsub(/^/, '    ') %>
<% end %>
<% end %>
